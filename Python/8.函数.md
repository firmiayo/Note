# 函数：

# 定义函数:

关键字：**def**:

```python
def greet_users():
    """显示简单的问候语"""  #文档字符串
    print('Hello Python world!')

greet_users()
```

+ 注意函数定义后以**”：“**结尾

+ **文档字符串**是一种注释，描述了函数是做什么的。它被三引号括起来，Python使用它们来生成有关程序中函数的文档。

   

## 向函数传递信息：

```python
def greet_user(ele):
    """显示简单的问候语"""
    print(f"Hello {ele.title()}")

greet_user('firmiyao')
#输出：Hello Firmiyao
```



## 实参与形参：

+ **形参**：（parameter）是函数完成工作所需的信息。
+ **实参**：（argument）即调用函数时传递给函数的信息。

# 传递实参：

**函数定义中可能含有多个形参，因此函数调用中也可能含多个实参。向函数传递实参的方式很多：可使用_位置实参_,这要求实参的顺序与形参的顺序相同；也可以使用_关键字实参_，其中每个实参都用变量名和值组成；还可以使用列表和字典。**

## 位置实参：:star:

**一句话，即一对一**

```python
#输出球员信息
def player_infor (name,club):
    print(f"{name.title()} is from {club.title()}")
player_infor('firmino','liverpool')
#输出：Firmino is from Liverpool
```

**可想而知，如果'firmino'和'liverpool'位置颠倒的话......这就是一对一**



## 关键字实参：:star2:

+ **关键字实参是传递给函数的_名称值对_，因为直接在实参中将名字和值关联起来，所以向函数传递实参时不会混淆。**

+ **关键字实参让你无须考虑函数调用中的实参顺序，还请楚地指出了函数调用中各个值的用途**

+ **关键字实参的顺序无关紧要，因为Python知道各个值该赋给哪个形参**

```python
def player_infor (name,club):
    print(f"{name.title()} is from {club.title()}")
player_infor(club='liverpool',name='firmino')
#输出：Firmino is from Liverpool
```

**可见实参和形参不一一对应也可进行传递**



## 默认值：

**编写函数时，可以给每个<u>形参</u>指定默认值。**在调用函数中给**形参**提供了**实参**时，Python将使用指定的实参值，否则，将使用形参的默认值。因此，给形参指定的默认之后，可在函数调用中省略相应的实参。’

```python
def play_infor (comment,name='firmino'):
    print(f'{name.title()} is {comment}')
play_infor(comment='cool',name='mane')  #有实参就用实参
play_infor(comment='handsome')  #实参”name“没有被赋值
play_infor('handsome')
```

![image-20220831200802544](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202208312008567.png)



**即使有默认值，但依旧遵循位置实参的语法以及关键字实参，且后者大于前者**



# 返回值：

+ **函数可以返回一个或一组值。函数返回的值称为返回值。**
+ 在函数中，可以使用**return**语句将值返回到调用函数的代码行。



## 返回简单值：

```python
def full_name(firsr,second,third='帅逼！'):#可以添加默认值
    """返回整洁的名字"""
    full=f"{firsr.title()} {second} {third}"
    return full
name=full_name("yang","yao")
print(name)  #Yang yao 帅逼！
```



## 返回字典：

**函数可以返回任何类型的值，包括列表和字典等较复杂的数据结构**

```python
def infor(first,second,age=None):
    user={} #先建立一个空字典
    if age:
        user['age']=age
    user['first_name']=first.title()
    user['second_name']=second.title()
    return user
use_1=infor('yang','yao',12)
print(use_1)
user_2=infor('zhao','diao')
print(user_2)
```

![image-20220831223220693](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202208312232722.png)



# 传递列表：

```python
def hi (users):
    """向每个用户问好"""
    for user in users:
        print(f"Hello, {user.title()}")
        
use=['yang yao','zhao diao']
hi(use)
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202208312238415.png" alt="image-20220831223820392"  />

## 在函数修改列表：

将列表传递给函数后，函数就可以对其进行修改。在函数中对这个列表所做的任何修改都是**永久性**的。

```python
#用户验证后移入新表
def change (unconfirm,confirm):
    """进行验证"""
    while unconfirm:
        ok=unconfirm.pop()
        confirm.append(ok)
def show(confirm):
    """展示已验证用户"""
    for user in confirm:
        print(f"{user.title()} is confirmed!")
unconfirm=['yang yao','zhao diao']
confirm=[]
change(unconfirm,confirm)
show(confirm)
```

![image-20220831225207962](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202208312252997.png)



## 禁止函数修改列表：

由上述内容可见，函数会将列表的值修改，但有时候我们需要原表，这时候可向函数传递列表的**副本**而非原件

要传递列表的**副本**可以这样：***function_name(list_name[:])***

```python
#用户验证后移入新表
def change (unconfirm,confirm):
    """进行验证"""
    while unconfirm:
        ok=unconfirm.pop()
        confirm.append(ok)
def show(confirm):
    """展示已验证用户"""
    for user in confirm:
        print(f"{user.title()} is confirmed!")
unconfirm=['yang yao','zhao diao']
confirm=[]
change(unconfirm[:],confirm)  #此处是传递了unconfirm的副本
show(confirm)
print('\nThis is unconfirm_list:')
print(unconfirm)  #不影响原来的列表
```

![image-20220831230612315](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202208312306341.png)



虽然向函数传递列表的副本可保留原始列表的内容，**但除非有充分的理由，否则还是应该将原始列表传递给函数。这是因为让函数使用现成的列表可以避免花费时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此**

# 传递任意数量的实参：

*有时候，预先不知道函数需要接受多少个实参，好在python允许函数从调用语句中收集任意数量的实参。*

```python
def make_pizza (*toppings):
    #输出披萨的原料
    print('The pizza is made of:')
    for ele in toppings:
        print(f" -{ele.upper()}")
make_pizza('mushroom','cheese','opinion')
```

![image-20220831232020475](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202208312320501.png)

__形参名*toppings中的星号让Python创建了一个名为toppings的空元组，并将收集到的所有值都封装到这个元组中__

Python 将收到的实参都存到了**元组**中，哪怕只有一个元素。



## 结合使用位置实参和任意数量实参:

