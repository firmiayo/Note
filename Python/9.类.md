# 类：

**面向对象编程**是最有效的软件编程方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程课模拟现实情景，其逼真程度达到了**令人惊叹**的地步。



## 创建和使用类：

***使用类几乎可以模拟任何东西***

### 创建dog类

它表示的不是特定的小狗，而是任何小狗，它具有小狗的任何属性，如有名字，会吃饭拉屎等。

```python
class Dog:
    """一次模拟小狗的简单尝试"""
    
    def _init_(self,name,age):
        """初始化属性name和age"""
        self.name=name
        self.age=age
        
	def sit(self):
        """模拟小狗坐下"""
        print(f"{self.name.title()} is now sitting.")

    def roll_over(self):
        """模拟小狗收到命令时打滚"""
        print(f"{self.name.title()} is now rolled over!")
```

+ class 指类
+ 类中的**函数**称为**方法**

#### 方法init():

+ 方法init（）是一个特殊的方法，每当你根据**类**创建新实列时，python都会自动运行它。

+ 在init（）的开头和末尾各有**两个下划线**，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。
+ **self**会自动传递，因此不需要传递它。

```python
class Dog:
    """一次模拟小狗的简单尝试"""

    def __init__(self,name,age):  #init前后分别是两个下划线
        """初始化属性name和age"""
        self.name=name
        self.age=age

    def sit(self):
        """模拟小狗坐下"""
        print(f"{self.name.title()} is now sitting.")

    def roll_over(self):
        """模拟小狗收到命令时打滚"""
        print(f"{self.name.title()} is now rolled over!")

my_dog = Dog('zhao',19)

print(f"My dog's name is {my_dog.name.title()}.And it is {my_dog.age} years old.")  #访问属性
my_dog.sit()  #调用方法
```

![image-20220903133834865](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202209031338899.png)

**命名约定：通常认为首字母大写的名称（如Dog）值的是类，而小写的（如my_dog）指的是根据类创建的实列**



## 使用类和实例：

```python
#编写一个表示汽车的类：
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make=make
        self.model=model
        self.year=year
        self.odometer=0  #设置汽车的里程，并将其初始化为0，即设置了默认值
    def describe(self):
        """返回对车的描述"""
        long_name=(f"{self.year} {self.make} {self.model}")
        return long_name.title()

my_car=Car('audi','a4','2020')
name=my_car.describe()
print(name.title())
#输出：2020 Audi A4
```



### 修改属性的值：

修改属性的值由三种方法：**直接通过实列进行修改**，**通过方法进行设置**，**以及通过方法进行递增**：

```python
#编写一个表示汽车的类：
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make=make
        self.model=model
        self.year=year
        self.odometer=0  #设置汽车的里程，并将其初始化为0，即设置了默认值
    def describe(self):
        """返回对车的描述"""
        long_name=(f"{self.year} {self.make} {self.model}")
        return long_name.title()
    def update_odometer(self,new_meter):
        self.odometer=new_meter
    
    def update_2(self,add_meter):
        self.odometer=self.odometer+add_meter
    
    def show_odometer(self):
        return self.odometer

my_car=Car('audi','a4','2020')
name=my_car.describe()
print(name.title())
#输出：2020 Audi A4

#直接通过示例进行修改
my_car.model='R8'
print(f"After modifying the model:{my_car.describe()}")
#通过方法修改属性的值：
my_car.update_odometer(20)
print(f"After modifying the odometer:{my_car.show_odometer()}")
#通过方法对属性的值进行递增：
my_car.update_2(30)   #记得前面的值为20，所有加30等于50
print(f"After modifying the odometer again:{my_car.show_odometer()}")
```

![image-20220903141701327](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202209031417357.png)



# 继承：:fire:

+ **编写类时，并非总是要从空白开始。如果要编写的类是另一个现成类的的特殊版本，可以使用继承。**
+ **一个类继承另一个类时，将自动获取另一个类的所有属性和方法。**
+ 原有的类称为父类，而新的类称为子类。
+ 子类继承了父类的所有属性和方法，同时还可以定义自己的属性和方法。



### 子类的方法init（）：

在既有类的基础上编写新类时，通常需要调用父类的方法init（）。这将初始化在父类init（）方法中定义的所有属性，从而让子类包含这些属性。

下面来创建一个Electric Car类，它具备Car类的所有功能：

```python
#编写一个表示汽车的类：
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make=make
        self.model=model
        self.year=year
        self.odometer=0  #设置汽车的里程，并将其初始化为0，即设置了默认值
    def describe(self):
        """返回对车的描述"""
        long_name=(f"{self.year} {self.make} {self.model}")
        return long_name.title()

    def update_2(self,add_meter):
        self.odometer=self.odometer+add_meter
    
    def show_odometer(self):
        return self.odometer

class ElectricCar(Car):
    """电动车的独特之处："""
    def __init__(self,make,model,year):
        """初始化父类的属性"""
        super().__init__(make,model,year)
        
my_tesla=ElectricCar('tesla','model s','2021')
print(my_tesla.describe())
#输出：2021 Tesla Model S
```



**super（）是一个特殊函数，让你能够调用父类的方法。这行代码让Python调用Car类的方法init（），让Electric Car实例包含这个方法中定义的所有属性。父类也称为超类（superclass），名称super由此而来。**



### 给子类定义属性和方法：

```python
#编写一个表示汽车的类：
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make=make
        self.model=model
        self.year=year
        self.odometer=0  #设置汽车的里程，并将其初始化为0，即设置了默认值
    def describe(self):
        """返回对车的描述"""
        long_name=(f"{self.year} {self.make} {self.model}")
        return long_name.title()

    def update_2(self,add_meter):
        self.odometer=self.odometer+add_meter
    
    def show_odometer(self):
        return self.odometer

class ElectricCar(Car):
    """电动车的独特之处："""
    def __init__(self,make,model,year):
        """初始化父类的属性"""
        super().__init__(make,model,year)
        self.battery_size=75   #添加电瓶大小容量这个属性
        
my_tesla=ElectricCar('tesla','model s','2021')
print(f"My tesla's battery_size is {my_tesla.battery_size}")
#输出：My tesla's battery_size is 75
```

*见25行代码*

### 重写父类的方法：

***对于父类的方法，只要它不符合子类模拟的实物的行为，都可以进行重写。为此，可在子类中定义一个与要重写的父类方法_同名_的方法。这样，Python将不会考虑这个父类方法，而只考虑你在子类中定义的相应方法***

```python
#编写一个表示汽车的类：
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make=make
        self.model=model
        self.year=year
        self.tank=80  #设置汽车的里程，并将其初始化为0，即设置了默认值
    def describe(self):
        """返回对车的描述"""
        long_name=(f"{self.year} {self.make} {self.model}")
        return long_name.title()

    def showtank_size(self):
        print(f"The tank is {self.tank}.")

class ElectricCar(Car):
    """电动车的独特之处："""
    def __init__(self,make,model,year):
        """初始化父类的属性"""
        super().__init__(make,model,year)
        self.battery_size=75   #添加电瓶大小容量这个属性
    
    #对showtank_size进行重写，因为电动车没有油箱
    def showtank_size(self):
        print(f"The car doesn't have a tank.")
        
my_tesla=ElectricCar('tesla','model s','2021')
my_tesla.showtank_size()
#输出：The car doesn't have a tank.
```



### 将实例用作属性：:fire:

***使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可将需要将类的一部分提取出来，，作为一个独立的类。可以将大型类拆分成多个表协同工作的小类。***



例：不断给Electric Car添加细节时，可以命名一个名为Battery的类，并将一个Battery实例作为Electric Car类的属性。

```python
#编写一个表示汽车的类：
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make=make
        self.model=model
        self.year=year
        self.tank=80  #设置汽车的里程，并将其初始化为0，即设置了默认值
    def describe(self):
        """返回对车的描述"""
        long_name=(f"{self.year} {self.make} {self.model}")
        return long_name.title()

    def showtank_size(self):
        print(f"The tank is {self.tank}.")

class Battery:
    """一次模拟电动汽车电流的简单尝试"""
    def __init__(self,battery_size=90):  #电瓶大小默认为90
        self.battery_size=battery_size   #添加属性
        
    def describe_battery(self):
        print(f"The battery'size is {self.battery_size} .")

class ElectricCar(Car):
    """电动车的独特之处："""
    def __init__(self,make,model,year):
        """初始化父类的属性"""
        super().__init__(make,model,year)
        self.battery=Battery()   #添加电瓶大小容量这个属性
    
    #对showtank_size进行重写，因为电动车没有油箱
    def showtank_size(self):
        print(f"The car doesn't have a tank.")
        
my_tesla=ElectricCar('tesla','model s','2021')
my_tesla.describe()
my_tesla.battery.__init__(100) #重置电池大小
my_tesla.battery.describe_battery()
```

![image-20220903153322560](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202209031533601.png)



# 导入类：

**随着不断给类添加功能，文件可能变得很长，即便妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。Python在这方面提供了帮助，允许将类存储在模块中，然后在主程序中导入所需的模块。**

## 导入单个类：

